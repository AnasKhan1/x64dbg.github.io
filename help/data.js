var contents = new Array("\n\r\n\radd\n\r   Add two values.\n\r\n\r  arguments\n\r&nbsp; arg1: Destination.\n\r\n\r&nbsp; arg2: Source.     \n\r\n\rresult\n\r   This command does not set any result&nbsp;variables.   ","add","scr\\add.htm","\n\r\n\ralloc\n\rAllocate memory in the debuggee (using VirtualAllocEx). The memory is allocated with PAGE_EXECUTE_READWRITE protection.\n\r\n\rarguments\n\r[arg1]: Size of the memory to allocate. When not specified, a default size of 0x1000 is used.\n\r\n\rresult\n\rThis command sets $result to the allocated memory address. It also sets the $lastalloc variable to the allocated memory address when VirtualAllocEx succeeded.","alloc","scr\\alloc.htm","\n\r\n\rand\n\rBinary AND two values.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\r&nbsp;  arg2: Source.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","and","scr\\and.htm","\n\r\n\rasm\n\rAssemble an instruction.\n\r\n\rarguments \n\r&nbsp; arg1: Address to place the assembled instruction at. \n\r\n\r &nbsp; arg2: Instruction text. \n\r\n\r[arg3]: When specified the remainder of the previous instruction will be filled with NOPs. \n\r\n\rresult\n\r$result will be set to the assembled instruction size. 0 on failure.","asm","scr\\asm.htm","\n\r\n\rAttachDebugger[,attach]\n\rAttach the debugger to a running process.\n\r\n\rarguments\n\r&nbsp; arg1: Process Identifier (PID) of the running process.\n\r\n\r[arg2]: Handle to an Event Object to signal (this is for internal use only).\n\r\n\rresult \n\rThis command will give control back to the user&nbsp;after the&nbsp;system breakpoint&nbsp;is reached. It will set&nbsp;$pid&nbsp;and&nbsp;$hp/$hProcess&nbsp;variables.      ","AttachDebugger/attach","scr\\AttachDebugger_attach.htm","\n\r\n\rbookmark[,bookmarkset]\n\rSet a bookmark.\n\r\n\rarguments \n\r&nbsp; arg1:&nbsp;Address to set the bookmark at (preferably inside a module). \n\r\n\rresult\n\rThis command does not set any result variables.","bookmark/bookmarkset","scr\\bookmark_bookmarkset.htm","\n\r\n\rbookmarkc[,bookmarkdel]\n\rDelete a bookmark.\n\r\n\rarguments \n\r    &nbsp; arg1:&nbsp;Address of the bookmark to delete. \n\r\n\rresult \n\rThis command does not set any result variables.","bookmarkc/bookmarkdel","scr\\bookmarkc_bookmarkdel.htm","\n\r\n\rbookmarklist\n\rList user-defined bookmarks in reference view.\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\rresult\n\r$result will be set to the number of user-defined bookmarks.","bookmarklist","scr\\bookmarklist.htm","\n\r\n\rbplist\n\rGet a list of breakpoints. This list includes their state (enabled/disabled), their type, their address and (optionally) their names.\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\rresult\n\r        This command does not set any result variables. A list entry has the following format:\n\r\n\rSTATE:TYPE:ADDRESS[:NAME]\n\r\n\rSTATE can be 0 or 1. 0 means disabled, 1 means enabled. Only singleshoot and \'normal\' breakpoints can be disabled.\n\r\n\rTYPE can be one of the following values: BP, SS, HW and GP. BP stands for a normal breakpoint (set using the SetBPX command), SS stands for SINGLESHOT, HW stands for HARDWARE and GP stand for Guard Page, the way of setting memory breakpoints.\n\r\n\rADDRESS is the breakpoint address, given in 32 and 64 bits for the x32 and x64 debugger respectively.\n\r\n\rNAME      is the name assigned to the breakpoint.","bplist","scr\\bplist.htm","\n\r\n\rBreakpoints\n\rThis section contains various breakpoint-related commands.","Breakpoints","scr\\Breakpoints.htm","\n\r\n\rCalculations\n\rThe debugger allows usage of basic math operations, just type an expression in the command window and the result will be displayed in the console. Apart from calculations, it allows quick&nbsp;variable changes using a C-like syntax.\n\r\n\rOperators\n\r  You can use the following operators in your expression. They are processed in the following order:\n\r\n\r0:negative            : Negative numbers can be prefixed by a \'-\' sign.\n\r\n\r1:brackets: \'(\' and \')\' Brackets are resolved first, there is no need for a terminating bracket, unless you want to use one.\n\r\n\r2:not: \'~\' The not operator can be used before a number of a variable, like in C.\n\r\n\r3:muliplication/devision: \'*\' = regular multiplication (signed/unsigned), \'$\' = get the higher part of the multiplication, \'/\' = regular devision (signed/unsigned, devide by zero=error) and \'%\' = get the modulo (remainder) of the devision.\n\r\n\r4:addition/substraction: \'+\' and \'-\'\n\r\n\r5:shift: \'&lt;\' = shift left (shl for unsigned, sal for signed), \'&gt;\' = shift right (shr for unsigned, sar for signed).\n\r\n\r6:and: \'&amp;\' Just the regular AND operation like in C.\n\r\n\r7:xor: \'^\' Just the regular XOR operation like in C.\n\r\n\r8:or: \'|\' Just the regular OR operation like in C.\n\r\n\rQuick-Assigning\n\rChanging memory, a variable, register or&nbsp;flag can be easily done using a C-like syntax:\n\r\n\ra?=b: \'?\' can be any mathematical operation. \'a\' can be any register, flag, variable or memory location. \'b\' can be anything that is recognized as a mathmatical input.\n\r\n\ra++/a--: \'a\' can be any register, flag, variable or memory location.","Calculations","scr\\Calculations.htm","\n\r\n\rcall\n\rA call works exactly the same as an uncondentional branch, but it places it\'s address on the script stack.\n\r\n\rarguments \n\r&nbsp;&nbsp;arg1: The label to jump to.\n\r\n\rresult \n\rThis command does not set any result variables. ","call","scr\\call.htm","\n\r\n\rCallback structures\n\rThese&nbsp;structures are used inside event callbacks (registered using _plugin_registercallback). Notice that the pointer \'void* callbackInfo\' is never NULL, but the members of the various structures can be NULL. Also remember that you cannot use any of the provided pointers out of the callback function scope. In general    AVOID time-consuming operations inside callbacks    , do these in separate                                             threads.\n\r\n\r//Called on debug initialization, useful to initialize some variables.\n\rstruct PLUG_CB_INITDEBUG       \n\r{\n\r&nbsp;&nbsp;&nbsp; const char*   szFileName;\n\r};\n\r\n\r//Called when the debugging has been stopped, useful to reset some variables.\n\rstruct PLUG_CB_STOPDEBUG          \n\r{\n\r&nbsp;&nbsp;&nbsp; void*  reserved;\n\r};\n\r\n\r//Called after process creation (in the debug loop), after the initialization of the symbol handler, the database file and setting breakpoints on TLS callbacks / the entry breakpoint.\n\rstruct PLUG_CB_CREATEPROCESS \n\r{\n\r&nbsp;&nbsp;&nbsp; CREATE_PROCESS_DEBUG_INFO*  CreateProcessInfo;\n\r&nbsp;&nbsp;&nbsp; IMAGEHLP_MODULE64*  modInfo;\n\r&nbsp;&nbsp;&nbsp; const char*   DebugFileName;\n\r&nbsp;&nbsp;&nbsp; PROCESS_INFORMATION*  fdProcessInfo;\n\r};\n\r\n\r//Called after the process exits (in the debug loop), before the symbol handler is cleaned up.\n\rstruct PLUG_CB_EXITPROCESS \n\r{\n\r&nbsp;&nbsp;&nbsp; EXIT_PROCESS_DEBUG_INFO*  ExitProcess;\n\r};\n\r\n\r//Called after thread creation (in the debug loop), after adding the thread to the internal thread list, before breaking the debugger on thread creation and&nbsp;after setting breakpoints on the thread entry.\n\rstruct PLUG_CB_CREATETHREAD\n\r{\n\r&nbsp;&nbsp;&nbsp; CREATE_THREAD_DEBUG_INFO* CreateThread;\n\r&nbsp;&nbsp;&nbsp; DWORD  dwThreadId;\n\r};\n\r\n\r//Called after thread termination (in the debug loop), before the thread is removed from the internal thread list, before breaking on thread termination.\n\rstruct PLUG_CB_EXITTHREAD \n\r{\n\r&nbsp;&nbsp;&nbsp; EXIT_THREAD_DEBUG_INFO* ExitThread;\n\r&nbsp;&nbsp;&nbsp; DWORD  dwThreadId;\n\r};\n\r\n\r//Called at the system breakpoint (in the debug loop), after setting the initial dump location, before breaking the debugger on the system breakpoint.\n\rstruct PLUG_CB_SYSTEMBREAKPOINT \n\r{\n\r&nbsp;&nbsp;&nbsp; void*  reserved;\n\r};\n\r\n\r//Called on DLL loading (in the debug loop), after the DLL has been added to the internal library list, after setting the DLL entry breakpoint.\n\rstruct PLUG_CB_LOADDLL \n\r{\n\r&nbsp;&nbsp;&nbsp; LOAD_DLL_DEBUG_INFO*  LoadDll;\n\r&nbsp;&nbsp;&nbsp; IMAGEHLP_MODULE64*  modInfo;\n\r&nbsp;&nbsp;&nbsp; const char*   modname;\n\r};\n\r\n\r//Called on DLL unloading (in the debug loop), before removing the DLL from the internal library list, before breaking on DLL unloading.\n\rstruct PLUG_CB_UNLOADDLL \n\r{\n\r&nbsp;&nbsp;&nbsp; UNLOAD_DLL_DEBUG_INFO*  UnloadDll;\n\r};\n\r\n\r//Called on a DebugString event (in the debug loop), before dumping the string to the log, before breaking on a debug string.\n\rstruct PLUG_CB_OUTPUTDEBUGSTRING \n\r{\n\r&nbsp;&nbsp;&nbsp; OUTPUT_DEBUG_STRING_INFO*  DebugString;\n\r};\n\r\n\r//Called on an unhandled (by the debugger) exception (in the debug loop), after setting the continue status, after locking the debugger to pause.\n\rstruct PLUG_CB_EXCEPTION \n\r{\n\r&nbsp;&nbsp;&nbsp; EXCEPTION_DEBUG_INFO*  Exception;\n\r};\n\r\n\r//Called on a normal/memory/hardware breakpoint (in the debug loop), after locking the debugger to pause.\n\rstruct PLUG_CB_BREAKPOINT \n\r{\n\r&nbsp;&nbsp;&nbsp; BRIDGEBP*  breakpoint;\n\r};\n\r\n\r//Called after the debugger has been locked to pause (in the debug loop), before any other callback that\'s before pausing the debugger.\n\rstruct PLUG_CB_PAUSEDEBUG \n\r{\n\r&nbsp;&nbsp;&nbsp; void*  reserved;\n\r};\n\r\n\r//Called after the debugger has been unlocked to resume (outside of the debug loop).\n\rstruct PLUG_CB_RESUMEDEBUG \n\r{\n\r&nbsp;&nbsp;&nbsp; void*  reserved;\n\r};\n\r\n\r//Called after the debugger stepped (in the debug loop), after locking the debugger to pause.\n\rstruct PLUG_CB_STEPPED \n\r{\n\r&nbsp;&nbsp;&nbsp; void*  reserved;\n\r};\n\r\n\r//Called before attaching to a process.\n\rstruct PLUG_CB_ATTACH\n\r{\n\r&nbsp;&nbsp;&nbsp; DWORD dwProcessId;\n\r};\n\r\n\r//Called before detaching from the process.\n\rstruct PLUG_CB_DETACH\n\r{\n\r&nbsp;&nbsp;&nbsp; PROCESS_INFORMATION* fdProcessInfo;\n\r};\n\r\n\r//Called on any debug event, even the ones that are handled internally, AVOID doing stuff that takes time here, this will slow the debugger down a lot!\n\rstruct PLUG_CB_DEBUGEVENT \n\r{\n\r&nbsp;&nbsp;&nbsp; DEBUG_EVENT* DebugEvent;\n\r};\n\r\n\r//Called when a menu entry created by the plugin has been clicked, the GUI will resume when this callback returns.\n\rstruct PLUG_CB_MENUENTRY\n\r{\n\r&nbsp;&nbsp;&nbsp; int hEntry;\n\r};\n\r\n\r//Called before TranslateMessage and DispatchMessage Windows functions (PreTranslateMessage). Avoid calling user32 functions without precautions here, there will be a recursive call if you fail to take countermeasures.\n\rstruct PLUG_CB_WINEVENT\n\r{\n\r&nbsp;&nbsp;&nbsp; MSG* message;\n\r&nbsp;&nbsp;&nbsp; long* result;\n\r&nbsp;&nbsp;&nbsp; bool retval; //only set this to true, never to false\n\r};\n\r\n\r//Called before TranslateMessage and DispatchMessage Windows functions (PreTranslateMessage). Avoid calling user32 functions without precautions here, there will be a recursive call if you fail to take countermeasures. This function is global, so it also captures hotkeys (see Qt documentation).\n\rstruct PLUG_CB_WINEVENTGLOBAL\n\r{\n\r&nbsp;&nbsp;&nbsp; MSG* message;\n\r&nbsp;&nbsp;&nbsp; bool retval; //only set this to true, never to false\n\r};","Callback Structures","scr\\Callbacks.htm","\n\r\n\rchd\n\rChange current directory (SetCurrentDirectory).\n\r\n\rarguments\n\r&nbsp; arg1: Path of a directory to change to.\n\r\n\rresult\n\rThis command does not set any result variables.","chd","scr\\chd.htm","\n\r\n\rcls[,lc,lclr]\n\rClear the log window.\n\r\n\r   arguments\n\rThis command has no arguments.\n\r\n\r    result\n\rThis command does not set any result variables.","cls/lc/lclr","scr\\cls.htm","\n\r\n\rcmp\n\rThis command compares two expressions. Notice that when you want to check for values being bigger or smaller, the comparison arg1&gt;arg2 is made. If this evaluates to true, the $_BS_FLAG is set to 1, meaning the value is internally bigger. So you test if arg1 is bigger/smaller than arg2.\n\r\n\rarguments\n\r&nbsp;arg1: First expression to compare.    \n\r\n\r&nbsp;arg2: Second expression to compare.    \n\r\n\rresult\n\rThis command sets the internal variables $_EZ_FLAG and $_BS_FLAG. They are checked when a branch is performed.    ","cmp","scr\\cmp.htm","\n\r\n\rcmt[,cmtset,commentset]\n\rSet a comment.\n\r\n\rarguments\n\r&nbsp; arg1:&nbsp;Address to set the comment at (preferably inside a module).\n\r\n\r            &nbsp; arg2: Comment text.\n\r\n\r  result\n\r       This command does not set any result variables.","cmt/cmtset/commentset","scr\\cmt_cmtset_commentset.htm","\n\r\n\rcmtc[,cmtdel,commentdel]\n\rDelete a comment.\n\r\n\rarguments\n\r&nbsp; arg1:&nbsp;Address of the comment to delete.\n\r\n\r  result\n\rThis command does not set any result variables.","cmtc/cmtdel/commentdel","scr\\cmtc_cmtdel_commentdel.htm","\n\r\n\r command[,alias1,alias2]\n\rCommand description here.\n\r\n\r\n\rarguments\n\r&nbsp; arg1: Argument description.\n\r\n\r[arg2]: Optional argument.\n\r\n\r[arg3]: Another optional argument (can only be given when the previous argument is also given).\n\r\n\r\n\rresult\n\rDescription of the command result.\n\r\n\r\n\rREMARK: Commands cannot contain any of the following characters: \",\" (comma), \" \" (space) and \"\\\" (backslash). These characters need to be prefixed using a backslash (\'\\,\').","Commands","scr\\Commands.htm","\n\r\n\rcommentlist\n\rList user-defined comments in reference view.\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\rresult\n\r$result will be set to the number of user-defined comments.","commentlist","scr\\commentlist.htm","\n\r\n\rData\n\rThis section contains commands that are used to analyze and manipulate data.","Data","scr\\Data.htm","\n\r\n\rDebug Control\n\rThis section contains commands useful for controlling the debugger (stepping etc.)","Debug Control","scr\\Debug_Control.htm","\n\r\n\rDebugContinue[,con]\n\rSet debugger continue status.\n\r\n\rarguments \n\r[arg1]: When set, the exception will be handled by the program. Otherwise the exception will be swallowed. \n\r\n\rresult\n\rThis command does not set any result variables.","DebugContinue/con","scr\\DebugContinue_con.htm","\n\r\n\rdec\n\rDecrease a value.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\rresult \n\rThis command does not set any result&nbsp;variables.","dec","scr\\dec.htm","\n\r\n\rDeleteBPX[,bpc,bc]\n\rDelete&nbsp;a breakpoint set using the SetBPX command.\n\r\n\rarguments\n\r[arg1]: Name or address of the breakpoint to delete. If this argument is not specified, all breakpoints will be deleted.\n\r\n\rresult\n\rThis command does not set any result variables.\n\r\n\r&nbsp;","DeleteBPX/bpc/bc","scr\\DeleteBPX_bpc_bc.htm","\n\r\n\rDeleteHardwareBreakpoint[,bphc,bphwc]\n\rDelete&nbsp;a hardware breakpoint set using the SetHardwareBreakpoint command.\n\r\n\rarguments\n\r[arg1]: Name or address of the hardware breakpoint to delete. If this argument is not specified, all hardware breakpoints will be deleted.\n\r\n\rresult\n\rThis command does not set any result variables.","DeleteHardwareBreakpoint/bphc/bphwc","scr\\DeleteHardwareBreakpoint_bphc_bphwc.htm","\n\r\n\rDeleteMemoryBPX[,membpc,bpmc]\n\rDelete&nbsp;a memory breakpoint set using the SetMemoryBPX command.\n\r\n\r  arguments\n\r[arg1]: Name or (base) address of the memory breakpoint to delete. If this argument is not specified, all memory breakpoints will be deleted.\n\r\n\rresult\n\rThis command does not set any result variables.","DeleteMemoryBPX/membpc/bpmc","scr\\DeleteMemoryBPX_membpc_bpmc.htm","\n\r\n\rDetachDebugger[,detach]\n\rDetach the debugger from the currently-debugged process.\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\rresult \n\rThis command does not set any result variables.","DetachDebugger/detach","scr\\DetachDebugger_detach.htm","DisableBPX[,bpd,bd]\n\rDisable&nbsp;a breakpoint set using the SetBPX command.\n\r\n\rarguments\n\r[arg1]: Name or address of the breakpoint to disable. If this argument is not specified, all breakpoints will be disabled.\n\r\n\rresult\n\rThis command does not set any result variables.","DisableBPX/bpd/bd","scr\\DisableBPX_bpd_bd.htm","\n\r\n\rDisableHardwareBreakpoint[,bphd,bphwd]\n\rDisable a hardware breakpoint.\n\r\n\rarguments\n\r[arg1]: Address of the hardware breakpoint to disable. If this argument is not specified, all hardware breakpoints will be disabled.\n\r\n\rresult\n\rThis command does not set any result variables.\n\r\n\r&nbsp;","DisableHardwareBreakpoint/bphd/bphwd","scr\\DisableHardwareBreakpoint_bphd_bphwd.htm","\n\r\n\rDisableMemoryBreakpoint[,membpd,bpmd]\n\rDisable a memory breakpoint.\n\r\n\rarguments\n\r[arg1]: Address of the memory breakpoint to disable. If this argument is not specified, all memory breakpoints will be disabled.\n\r\n\r result\n\rThis command does not set any result variables.","DisableMemoryBreakpoint/membpd/bpmd","scr\\DisableMemoryBreakpoint_membpd_bpmd.htm","\n\r\n\rdisasm[,dis,d]\n\r      Disassemble at a certain position.\n\r\n\rarguments\n\r[arg1]: The address to disassemble at. When not specified, there will be assembled at CIP.\n\r\n\rresult\n\rThis command does not set any result variables.","disasm/dis/d","scr\\disasm_dis_d.htm","\n\r\n\rdiv\n\rDevide&nbsp;two values.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\r&nbsp; arg2: Source.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","div","scr\\div.htm","\n\r\n\rdump\n\rDump at a certain position.\n\r\n\rarguments \n\r[arg1]: The address to dump at.\n\r\n\rresult\n\rThis command does not set any result variables.","dump","scr\\dump.htm","\n\r\n\rEnableBPX[,bpe,be]\n\rEnable a breakpoint set using the SetBPX command.\n\r\n\rarguments\n\r [arg1]: Name or address of the breakpoint to enable. If this argument is not specified, all breakpoints will be enabled.\n\r\n\rresult\n\rThis command does not set any result variables.","EnableBPX/bpe/be","scr\\EnableBPX_bpe_be.htm","\n\r\n\rEnableHardwareBreakpoint[,bphe,bphwe]\n\rEnable a previously disabled hardware breakpoint.\n\r\n\rarguments\n\r[arg1]: Address of the hardware breakpoint to enable. If this argument is not specified, as many as possible hardware breakpoints will be enabled.\n\r\n\rresult\n\rThis command does not set any result variables.","EnableHardwareBreakpoint/bphe/bphwe","scr\\EnableHardwareBreakpoint_bphe_bphwe.htm","\n\r\n\rEnableMemoryBreakpoint[,membpe,bpme]\n\rEnable a previously disabled memory breakpoint.\n\r\n\rarguments\n\r[arg1]: Address of the memory breakpoint to enable. If this argument is not specified, all memory breakpoints will be enabled.\n\r\n\r result\n\rThis command does not set any result variables.\n\r\n\r&nbsp;","EnableMemoryBreakpoint/membpe/bpme","scr\\EnableMemoryBreakpoint_membpe_bpme.htm","\n\r\n\rerun[,ego,er,eg]\n\rFree the lock and allow the program to run, skipping first-chance exceptions.\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\r result\n\r  This command does not set any result variables.\n\r\n\r&nbsp;","erun/ego/er/eg","scr\\erun_ego_er_eg.htm","\n\r\n\r  eSingleStep[,esstep,esst]\n\rStep a specified number of instructions using the Trap-Flag, skipping first-chance exceptions.\n\r\n\rarguments\n\r[arg1]: The number of instructions to executre (this can be any valid expression). When not specified, a StepInto is performed.\n\r\n\r\n\rresult\n\rThis command does not set any result variables.\n\r\n\r&nbsp;","eSingleStep/esstep/esst","scr\\eSingleStep_esstep_esst.htm","\n\r\n\reStepInto[,esti]\n\rSingle Step (using Trap-Flag), skipping first-chance exceptions.\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\r\n\rresult\n\rThis command does not set any result variables.\n\r\n\r&nbsp;","eStepInto/esti","scr\\eStepInto_esti.htm","\n\r\n\reStepOut[,ertr]\n\rReturn from function by calling eStepOver until the current instruction is a RET.\n\r\n\r  arguments\n\rThis command has no arguments. \n\r\n\rresult\n\rThis command does not set any result variables.","eStepOut/ertr","scr\\eStepOut_ertr.htm","\n\r\n\reStepOver[,estep,esto,est]\n\rStep over calls, skipping first-chance exceptions.&nbsp;When the instruction at CIP isn\'t a call,&nbsp;a StepInto is performed.\n\r\n\r  arguments\n\rThis command has no arguments. \n\r\n\rresult\n\rThis command does not set any result variables.","eStepOver/estep/esto/est","scr\\eStepOver_estep_esto_est.htm","\n\r\n\rExports\n\rThis section contains information about the \"_plugin_\" prefixed exports.","API","scr\\Exports.htm","\n\r\n\rFill[,memset]\n\rSet memory of the debuggee to a specified byte.\n\r\n\rarguments\n\r&nbsp; arg1: Memory address to start setting bytes.\n\r\n\r&nbsp; arg2: Value (byte) to set memory with.\n\r\n\r[arg3]: Size to set. When not specified the rest of the page is used.\n\r\n\rresult\n\rThis command does not set any result variables.","Fill/memset","scr\\Fill_memset.htm","\n\r\n\rfind\n\r  Find a pattern.\n\r\n\rarguments \n\r&nbsp; arg1: The address to start searching from. Notice that the searching will stop when the end of the memory page this address resides in has been reached. This means you cannot search the complete process memory without enumerating the memory pages first.\n\r\n\r&nbsp; arg2: The byte pattern to search for. This byte pattern can contain wildcards (?) for example: \"EB0?90??8D\".\n\r\n\r         [arg3]: The size of the data to search in.\n\r\n\rresult \n\rThe $result variable is set to the virtual address of the address that matches the byte pattern. $result will be 0 when the pattern could not be matched.\n\r\n\r&nbsp;","find","scr\\find.htm","\n\r\n\rfindall\n\rFind all occurrences of a pattern.\n\r\n\rarguments \n\r&nbsp; arg1: The address to start searching from. Notice that the searching will stop when the end of the memory page this address resides in has been reached. This means you cannot search the complete process memory without enumerating the memory pages first.\n\r\n\r&nbsp; arg2: The byte pattern to search for. This byte pattern can contain wildcards (?) for example: \"EB0?90??8D\".\n\r\n\r[arg3]: The size of the data to search in.\n\r\n\rresult \n\r$result is set to the number of occurrences.\n\r\n\r&nbsp;","findall","scr\\findall.htm","\n\r\n\rfindasm[,asmfind]\n\rFind assembled instruction.\n\r\n\rarguments \n\r&nbsp; arg1: Instruction to look for (make sure to use \"mov eax, ebx\" to ensure you actually search for that instruction). \n\r\n\r[arg2]: Address&nbsp;of/inside a memory page to look in. When not specified CIP will be used.&nbsp; \n\r\n\r[arg3]: The size of the data to search in. \n\r\n\rresult \n\rThe $result variable is set to the number of references found. ","findasm/asmfind","scr\\findasm_asmfind.htm","\n\r\n\rfree\n\r           Free&nbsp;memory in the debuggee (using VirtualFreeEx).\n\r\n\r     arguments\n\r [arg1]: Address of the memory to free. When not specified, the value at $lastalloc is used.\n\r\n\rresult\n\rThis command sets $result to 1 if VirtualFreeEx succeeded, otherwise it\'s set to 0. $lastalloc is set to zero when the address specified is equal to $lastalloc.","free","scr\\free.htm","\n\r\n\rfunctionadd[,func]\n\rAdd a function.\n\r\n\rarguments \n\r&nbsp; arg1:&nbsp;Function range start. \n\r\n\r&nbsp; arg2: Function range end.\n\r\n\rresult\n\rThis command does not set any result variables.","functionadd/func","scr\\functionadd_func.htm","\n\r\n\rfunctiondel[,funcc]\n\rDelete a function.\n\r\n\rarguments \n\r&nbsp; arg1:&nbsp;Address inside the function range&nbsp;to delete.\n\r\n\r  result\n\rThis command does not set any result variables.\n\r\n\r&nbsp;","functiondel/funcc","scr\\functiondel_funcc.htm","\n\r\n\rfunctionlist\n\rList user-defined functions in reference view.\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\rresult\n\r$result will be set to the number of user-defined functions.\n\r\n\r&nbsp;","functionlist","scr\\functionlist.htm","\n\r\n\rGeneral Purpose\n\rThis section contains various commands that are used for calculations etc.\n\r\n\r&nbsp;","General Purpose","scr\\General_Purpose.htm","\n\r\n\rgpa\n\rGet the address of an export inside a DLL.\n\r\n\rarguments \n\r&nbsp; arg1: Export name.\n\r\n\r[arg2]: DLL name.\n\r\n\r result\n\rThe $result variable is set to the export address. When the export is not found, $result   will be set to 0.","gpa","scr\\gpa.htm","\n\r\n\rHideDebugger[,dbh,hide]\n\r Hide the debugger from (very) simple detection methods.\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\rresult\n\rThis command does not set any result variables.","HideDebugger/dbh/hide","scr\\HideDebugger_dbh_hide.htm","\n\r\n\rinc\n\rIncrease a value.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","inc","scr\\inc.htm","\n\r\n\rInitDebug[,init,initdbg]\n\rInitializes the debugger. This command will load the executable (do some basic checks),&nbsp;set breakpoints on TLS callbacks    (if present), set a breakpoint at the process entry point&nbsp;and break at the system breakpoint before giving back control to the user.\n\r\n\rarguments\n\r&nbsp; arg1 : Path to the executable file to debug. If no full path is given, the GetCurrentDirectory API will be called to retrieve a full path. Use quotation marks to include spaces in your path.                         \n\r\n\r [arg2]: Commandline to create the process with.                         \n\r\n\r[arg3]: Current folder (passed to the CreateProcess API).                         \n\r\n\rresult\n\r       This command will give control back to the user&nbsp;after the&nbsp;system breakpoint&nbsp;is reached. It will set $pid and&nbsp;$hp/$hProcess&nbsp;variables.                         ","InitDebug/initdbg/init","scr\\InitDebug_initdbg_init.htm","\n\r\n\rInput\n\rThis program accepts various options of input:\n\r\n\r\n\rcommands: Commands have the following format: \"command[space]arg1,[optional space]arg2,argN\".\n\r\n\r\n\rvariables: Variables optionally start with a $ and can only store one DWORD (QWORD on x64).\n\r\n\r\n\rdebug registers: All debug registers (all sizes) can be used as variables.\n\r\n\r\n\rmemory locations: You can read from a memory location by using one of the following expressions:\n\r[addr]&nbsp;&nbsp;&nbsp; - read a DWORD/QWORD, depending on the architecture.\n\r                                                                      @addr&nbsp;&nbsp;&nbsp;&nbsp; - same as above.\n\rn:[addr]&nbsp;&nbsp;- read n                                                                      bytes.\n\r                @n:addr&nbsp;&nbsp; - same as above.\n\rREMARKS:\n\r- n is the amount of bytes to read, this can be anything smaller than 4 on x32 and smaller than 8 on x64 when specified, otherwise there will be an error.\n\r- addr is directly interpreted as a value, when you want to read [addr+1] you should use brackets:\n\r                                                                  @(addr+1), @addr+1 will read: [addr]+1.\n\r\n\r                                                                      flags      : Debug flags (interpreted as integer) can be used as input. Flags are prefixed with a \'!\' following the flag name. Valid flags are: !cf, !pf, !af, !zf, !sf, !tf, !if, !df, !of, !rf, !vm, !ac, !vif, !vip and !id.\n\r\n\rnumbers: All numbers are interpreted as hex by default. If you want to be sure, you can use the \"x\" prefix or the \"0x\" prefix. Decimal numbers can be used by prefixing the number with a \".\" (.123=7B).\n\r\n\rbasic calculations:           See \"Calculations\" for more information.\n\r\n\rDLL exports: Type \'GetProcAddress\' and it will automatically be resolved to the actual address of the function. To explicitly define from which module to load the API, use: \"kernel32.dll:GetProcAddress\" or \"kernel32:GetProcAddress\". In a similar way you can resolve ordinals, try \"ntdll:1\". Another macro allows you to get the loaded base of a module. Try                             \"ntdll:0\", \"ntdll:base\", \"ntdll:imagebase\" or \"ntdll:header\".\n\r\n\rlabels/symbols        : user-defined labels                             and symbols&nbsp;are a valid expressions.\n\r\n\rInput for arguments can always be done in any of the above forms, except if stated otherwise.                                                   ","Input","scr\\Input.htm","\n\r\n\rIntroduction\n\rThis is a x64/x32 debugger that is currently in active development.\n\r\n\rThe debugger (currently) has three parts:\n\r- DBG\n\r- GUI\n\r         - Bridge\n\r\n\rDBG is the debugging part of the debugger. It handles debugging (using\n\r   TitanEngine) and will provide data for the GUI.\n\r\n\rGUI is the graphical part of the debugger. It is built on top of Qt and it\n\r        provides the user interaction.\n\r\n\rBridge is the communication library for the DBG and GUI part (and maybe in\n\rthe future more parts). The bridge can be used to work on new features,\n\r without having to update the code of the other parts.","Introduction","scr\\Introduction.htm","\n\r\n\rinvalid\n\rInvalid command to throw an error message. This command will halt the script execution.\n\r\n\rarguments \n\rThis command has no arguments. \n\r\n\rresult \n\rThis command does not set any result variables. ","invalid","scr\\invalid.htm","\n\r\n\rJxx/IFxx\n\rThere are various branches that can react on the flags set by the \'cmp\' (and maybe other)&nbsp;command(s):\n\r  uncondentional branch &nbsp; -   jmp/goto  branch if not equal&nbsp;&nbsp; &nbsp; -   jne/ifne(q)/jnz/ifnz  branch if equal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp; - je/ife(q)/jz/ifz  branch if smaller&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; -   jb/ifb/jl/ifl  branch if bigger&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;   - ja/ifa/jg/ifg    branch if bigger/equal&nbsp; -   jbe/ifbe(q)/jle/ifle(q)  branch if smaller/equal -   jae/ifae(q)/jge/ifge(q)\n\r\n\r\n\rarguments \n\r&nbsp; arg1: The label to jump to.\n\r\n\rresult \n\rThis command does not set any result variables. ","Jxx/IFxx","scr\\Jxx_IFxx.htm","\n\r\n\rkillthread[,threadkill]\n\rKill a thread in the debuggee.\n\r\n\rarguments&nbsp;\n\r [arg1]:&nbsp;ThreadId of the thread to&nbsp;kill&nbsp;(see the Threads tab). When not specified, the main thread is used.&nbsp;\n\r\n\r           [arg2]: Thread exit code. When not           specified, 0 will be used.\n\r\n\rresult \n\rThis command does not set any result variables.","killthread/threadkill","scr\\killthread_threadkill.htm","\n\r\n\rlabellist\n\rList user-defined labels in reference view.\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\r result\n\r$result will be set to the number of user-defined labels.\n\r\n\r&nbsp;","labellist","scr\\labellist.htm","\n\r\n\rlbl[,lblset,labelset]\n\rSet a label.\n\r\n\rarguments\n\r&nbsp; arg1:&nbsp;Address to set the label at (preferably inside a module).\n\r\n\r &nbsp; arg2: Label text.\n\r\n\rresult\n\rThis command does not set any result variables.","lbl/lblset/labelset","scr\\lbl_lblset_labelset.htm","\n\r\n\rlblc[,lbldel,labeldel]\n\rDelete a label.\n\r\n\rarguments \n\r&nbsp; arg1:&nbsp;Address of the label to delete.\n\r\n\rresult \n\rThis command does not set any result variables.","lblc/lbldel/labeldel","scr\\lblc_lbldel_labeldel.htm","\n\r\n\rLibrarianRemoveBreakPoint[,bcdll]\n\rRemove a DLL breakpoint.\n\r\n\rarguments\n\r&nbsp; arg1: DLL Name to remove the breakpoint from.\n\r\n\rresult\n\rThis command does not set any result variables.\n\r\n\r&nbsp;","LibrarianRemoveBreakPoint/bcdll","scr\\LibrarianRemoveBreakPoint_bcdll.htm","\n\r\n\rLibrarianSetBreakPoint[,bpdll]\n\rSet a singleshoot breakpoint on DLL load/unload.\n\r\n\rarguments\n\r&nbsp; arg1: DLL Name to break on.\n\r\n\r[arg2]: \'l\' means on load, \'u\' means on unload. When not specified, x64_dbg will break on both load and unload.\n\r\n\r[arg3]: When specified, the breakpoint will not be singleshoot. When not specified the breakpoint will be removed after it has been hit.\n\r\n\rresult\n\rThis command does not set any result variables.","LibrarianSetBreakPoint/bpdll","scr\\LibrarianSetBreakPoint_bpdll.htm","\n\r\n\rloaddb[,dbload]\n\rLoad the program database from disk in memory.\n\r\n\r  arguments\n\rThis command has no arguments.\n\r\n\rresult \n\rThis command does not set any result variables. \n\r\n\r&nbsp;","loaddb/dbload","scr\\loaddb_dbload.htm","\n\r\n\rMemory Operations\n\rThis section contains commands to manipulate memory inside the debuggee.","Memory Operations","scr\\Memory_Operations.htm","\n\r\n\rMisc\n\rThis section contains all commands that do not directly fit in another section.","Misc","scr\\Misc.htm","\n\r\n\rmodcallfind\n\rFind all inter-modular calls.\n\r\n\rarguments \n\r[arg1]: Address of/inside a memory page to&nbsp;find inter-modular calls in. When not specified CIP will be used.\n\r\n\r[arg2]: The size of the data to search in.\n\r\n\rresult \n\rThe $result variable is set to the number of inter-modular calls found.","modcallfind","scr\\modcallfind.htm","\n\r\n\rmov[,set]\n\rSet a variable.\n\r\n\r\n\rarguments\n\r&nbsp; arg1: Variable name (optionally prefixed with a $) to set. When the variable does not exist, it will be created.       \n\r\n\r       &nbsp; arg2: Value to store in the variable.\n\r\n\r\n\rresult\n\rThis command does not set any result variables.","mov/set","scr\\mov_set.htm","\n\r\n\rmsg\n\rDisplay a message box.\n\r\n\rarguments\n\r&nbsp;arg1: Message box text.\n\r\n\rresult\n\rThis command does not set any result variables.","msg","scr\\msg.htm","\n\r\n\rmsgyn\n\rDisplay a message box, asking the user to answer yes or no.\n\r\n\rarguments\n\r&nbsp;arg1: Message box text.\n\r\n\rresult\n\rThe $result variable will be set to 1 when the user answered yes. Otherwise it\'s set to 0.","msgyn","scr\\msgyn.htm","\n\r\n\rmul\n\rMultiply two values.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\r&nbsp; arg2: Source.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","mul","scr\\mul.htm","\n\r\n\rneg\n\rNegate a value.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","neg","scr\\neg.htm","\n\r\n\rnot\n\rBinary NOT a value.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","not","scr\\not.htm","\n\r\n\ror\n\rBinary OR&nbsp;two values.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\r&nbsp; arg2: Source.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","or","scr\\or.htm","\n\r\n\rpause\n\rPause&nbsp;the debuggee.\n\r\n\rarguments \n\rThis command has no arguments.\n\r\n\rresult\n\rThis command does not set any result variables.\n\r\n\r&nbsp;","pause","scr\\pause.htm","\n\r\n\rpause\n\rHalt the script execution. The user can resume the script after this command.\n\r\n\rarguments \n\rThis command has no arguments.\n\r\n\rresult\n\r            This command does not set any result variables.","pause","scr\\pause_script.htm","\n\r\n\rplugsetup\n\rThis structure is used by the function that allows the creation of plugin menu entries:\n\r\n\r              struct PLUG_SETUPSTRUCT               \n\r{\n\r&nbsp;&nbsp;&nbsp; //data provided by the debugger to the plugin.        \n\r&nbsp;&nbsp;&nbsp; [IN] HWND   hwndDlg; //GUI window handle\n\r&nbsp;&nbsp;&nbsp; [IN] int   hMenu; //plugin menu handle\n\r              };","PLUG_SETUPSTRUCT","scr\\PLUG_SETUPSTRUCT.htm","\n\r\n\r_plugin_debugpause\n\rThis function returns debugger control to the user. You would use this function when you write an unpacker that needs support from x64_dbg (for example in development). Calling this function will set the debug state to \'paused\' and it will not return until the user runs the debuggee using the \'run\' command                                                   .\n\r\n\rvoid _plugin_debugpause();\n\r\n\rParameters \n\r\n\rThis function has no parameters.\n\r\n\rReturn Values\n\r This function does not return a value. ","_plugin_debugpause","scr\\plugin_debugpause.htm","\n\r\n\r_plugin_debugskipexceptions\n\rThis function returns sets if the debugger should skip first-chance exceptions. This is useful when creating unpackers or other plugins that run the debuggee.\n\r\n\rvoid _plugin_debugskipexceptions(\n\rbool skip //skip flag\n\r);\n\r\n\rParameters \n\r\n\rskip: Flag if we need to skip first-chance exceptions or not.\n\r\n\rReturn Values\n\rThis function does not return a value.","_plugin_debugskipexceptions","scr\\plugin_debugskipexceptions.htm","\n\r\n\r_plugin_logprintf\n\rThis function prints a message to the log window.\n\r\n\rvoid _plugin_logprintf(\n\r    const char* format,   //format string\n\r... //additional arguments\n\r);        \n\r\n\rParameters        \n\r\n\rformat: Format string that has the same specifications as printf.        \n\r\n\r... : Additional arguments (when needed by the format string).        \n\r\n\rReturn Values\n\rThis function does not return a value. ","_plugin_logprintf","scr\\plugin_logprintf.htm","\n\r\n\r_plugin_logputs\n\rThis function prints a single line to the log window.\n\r\n\rvoid _plugin_logputs(\n\rconst char* text //text to print\n\r);         \n\r\n\r Parameters     \n\r\n\rtext: Piece of text to put to the log window. This text can contain line breaks.\n\r\n\rReturn Values\n\rThis function does not return a value. ","_plugin_logputs","scr\\plugin_logputs.htm","\n\r\n\r_plugin_menuadd\n\rThis function adds a new child menu to a menu.\n\r\n\rint&nbsp;_plugin_menuadd(\n\rint hMenu, //menu handle to add the new child menu to\n\rconst char* title //child menu title\n\r);\n\r\n\rParameters \n\r\n\rhMenu: Menu handle from a previously-added child menu or from the main plugin menu.\n\r\n\rtitle        : Menu title.\n\r\n\rReturn Values\n\r    Returns the    child menu handle (unique), -1 on failure.","_plugin_menuadd","scr\\plugin_menuadd.htm","\n\r\n\r_plugin_menuaddentry\n\rThis function adds a menu entry to a menu.\n\r\n\rbool&nbsp;_plugin_menuaddentry(\n\rint hMenu, //menu handle to add the new child menu to\n\rint hEntry, //plugin-wide identifier for the menu entry\n\rconst char* title //menu entry title\n\r);\n\r\n\rParameters \n\r\n\rhMenu: Menu handle from a previously-added child menu or from the main plugin menu.\n\r\n\rhEntry: A plugin-wide identifier for the menu entry. This is the value you will get in the PLUG_CB_MENUENTRY callback structure.\n\r\n\rtitle : Menu entry&nbsp;title.\n\r\n\rReturn Values \n\rReturns true when the entry was added without problems, false otherwise.\n\r\n\r&nbsp;","_plugin_menuaddentry","scr\\plugin_menuaddentry.htm","\n\r\n\r_plugin_menuaddseparator\n\rThis function adds a new child menu to a menu.\n\r\n\rbool&nbsp;_plugin_menuaddseparator(\n\rint hMenu //menu handle to add the separator to\n\r );\n\r\n\rParameters\n\r\n\rhMenu: Menu handle from a previously-added child menu or from the main plugin menu.\n\r\n\rReturn Values \n\rReturns true on success.","_plugin_menuaddseparator","scr\\plugin_menuaddseparator.htm","\n\r\n\r_plugin_menuclear\n\rThis function removes all entries and child menus from a menu. It will not remove the menu itself.\n\r\n\rbool&nbsp;_plugin_menuclear(\n\r inthMenu//menu handle&nbsp;of the menu to clear&nbsp;\n\r);\n\r\n\rParameters\n\r\n\rhMenu: Menu handle from a previously-added child menu or from the main plugin menu.\n\r\n\rReturn Values \n\rReturns true on success.","_plugin_menuclear","scr\\plugin_menuclear.htm","\n\r\n\r_plugin_registercallback\n\rThis function registers an event callback for a plugin. Every plugin can have it\'s own callbacks for every event. It is not possible to have multiple callbacks on the same event.\n\r\n\rvoid _plugin_registercallback(\n\rint pluginHandle, //plugin handle\n\rCBTYPE cbType, //event type\n\rCBPLUGIN cbPlugin //callback function\n\r);                              \n\r\n\rParameters                              \n\r\n\rpluginHandle: Handle of the calling plugin.                              \n\r\n\rcbType: The event type. This can be any of the following values:\n\r&nbsp;&nbsp;&nbsp; CB_INITDEBUG, //callbackInfo: PLUG_CB_INITDEBUG*\n\r&nbsp;&nbsp;&nbsp; CB_STOPDEBUG, //callbackInfo: PLUG_CB_STOPDEBUG*\n\r&nbsp;&nbsp;&nbsp; CB_CREATEPROCESS, //callbackInfo: PLUG_CB_CREATEPROCESS*\n\r&nbsp;&nbsp;&nbsp; CB_EXITPROCESS, //callbackInfo: PLUG_CB_EXITPROCESS*\n\r&nbsp;&nbsp;&nbsp; CB_CREATETHREAD, //callbackInfo: PLUG_CB_CREATETHREAD*\n\r&nbsp;&nbsp;&nbsp; CB_EXITTHREAD, //callbackInfo: PLUG_CB_EXITTHREAD*\n\r&nbsp;&nbsp;&nbsp; CB_SYSTEMBREAKPOINT, //callbackInfo: PLUG_CB_SYSTEMBREAKPOINT*\n\r&nbsp;&nbsp;&nbsp; CB_LOADDLL, //callbackInfo: PLUG_CB_LOADDLL*\n\r&nbsp;&nbsp;&nbsp; CB_UNLOADDLL, //callbackInfo: PLUG_CB_UNLOADDLL*\n\r&nbsp;&nbsp;&nbsp; CB_OUTPUTDEBUGSTRING, //callbackInfo: PLUG_CB_OUTPUTDEBUGSTRING*\n\r&nbsp;&nbsp;&nbsp; CB_EXCEPTION, //callbackInfo: PLUG_CB_EXCEPTION*\n\r&nbsp;&nbsp;&nbsp; CB_BREAKPOINT, //callbackInfo: PLUG_CB_BREAKPOINT*\n\r&nbsp;&nbsp;&nbsp; CB_PAUSEDEBUG, //callbackInfo: PLUG_CB_PAUSEDEBUG*\n\r&nbsp;&nbsp;&nbsp; CB_RESUMEDEBUG, //callbackInfo: PLUG_CB_RESUMEDEBUG*\n\r&nbsp;&nbsp;&nbsp; CB_STEPPED, //callbackInfo: PLUG_CB_STEPPED* \n\r&nbsp;&nbsp;&nbsp; CB_ATTACH, //callbackInfo: PLUG_CB_ATTACHED*\n\r&nbsp;&nbsp;&nbsp; CB_DETACH, //callbackInfo: PLUG_CB_DETACHED*\n\r&nbsp;&nbsp;&nbsp; CB_DEBUGEVENT, //callbackInfo: PLUG_CB_DEBUGEVENT*\n\r&nbsp;&nbsp;&nbsp; CB_MENUENTRY, //callbackInfo: PLUG_CB_MENUENTRY*\n\r&nbsp;&nbsp;&nbsp; CB_WINEVENT //callbackInfo: PLUG_CB_WINEVENT* \n\r&nbsp;&nbsp;&nbsp; CB_WINEVENTGLOBAL //callbackInfo: PLUG_CB_WINEVENTGLOBAL*                              \n\r\n\rcbPlugin: Callback with the following typdef:\n\r&nbsp;&nbsp;&nbsp; void CBPLUGIN(\n\r&nbsp;&nbsp;&nbsp; CBTYPE bType //event type (useful when you use the same function for multiple events\n\r&nbsp;&nbsp;&nbsp; void* callbackInfo //pointer to a structure of information (see above)\n\r&nbsp;&nbsp;&nbsp; );                                \n\r\n\rReturn Values\n\rThis function does not return a value.                                ","_plugin_registercallback","scr\\plugin_registercallback.htm","\n\r\n\r_plugin_registercommand\n\rThis function registers a command for usage inside scripts or the command bar.\n\r\n\rbool _plugin_registercommand( \n\rint pluginHandle, //plugin handle\n\rconst char* command, //command name\n\rCBPLUGINCOMMAND cbCommand, //function that is called when the command is executed\n\rbool debugonly //restrict the command to debug-only\n\r);\n\r\n\rParameters\n\r\n\rpluginHandle: Handle of the calling plugin.\n\r\n\rcommand: Command name.\n\r\n\rcbCommand: Callback with the following typedef:\n\r&nbsp;&nbsp;&nbsp; bool CBPLUGINCOMMAND(\n\r&nbsp;&nbsp;&nbsp; int argc //argument count (number of&nbsp;arguments + 1)\n\r&nbsp;&nbsp;&nbsp; char* argv[] //array of arguments (argv[0] is the full command, arguments start at argv[1])\n\r&nbsp;&nbsp;&nbsp; ); \n\r\n\rdebugonly: When set, the command will never be executed when there is no target is&nbsp;being debugged. \n\r\n\rReturn Values\n\rThis function returns true when the command was successfully registered, make sure to check this, other plugins may have already registered the same command.                ","_plugin_registercommand","scr\\plugin_registercommand.htm","\n\r\n\r_plugin_unregistercallback\n\rThis plugin unregisters a previously set callback. It is only possible to remove callbacks that were previously set using _plugin_registercallback.\n\r\n\rbool _plugin_unregistercallback( \n\rint pluginHandle, //plugin handle\n\rCBTYPE cbType //callback type to remove\n\r);                     \n\r\n\rParameters                     \n\r\n\rpluginHandle: Handle of the calling plugin.                     \n\r\n\rcbType: The event type. This can be any of the following values:\n\r  &nbsp;&nbsp;&nbsp; CB_INITDEBUG,\n\r  &nbsp;&nbsp;&nbsp; CB_STOPDEBUG,\n\r  &nbsp;&nbsp;&nbsp; CB_CREATEPROCESS, \n\r  &nbsp;&nbsp;&nbsp; CB_EXITPROCESS,\n\r  &nbsp;&nbsp;&nbsp; CB_CREATETHREAD,\n\r  &nbsp;&nbsp;&nbsp; CB_EXITTHREAD,\n\r  &nbsp;&nbsp;&nbsp; CB_SYSTEMBREAKPOINT,\n\r  &nbsp;&nbsp;&nbsp; CB_LOADDLL,\n\r  &nbsp;&nbsp;&nbsp; CB_UNLOADDLL,\n\r  &nbsp;&nbsp;&nbsp; CB_OUTPUTDEBUGSTRING,\n\r  &nbsp;&nbsp;&nbsp; CB_EXCEPTION,\n\r  &nbsp;&nbsp;&nbsp; CB_BREAKPOINT,\n\r  &nbsp;&nbsp;&nbsp; CB_PAUSEDEBUG,\n\r  &nbsp;&nbsp;&nbsp; CB_RESUMEDEBUG,\n\r&nbsp;&nbsp;&nbsp; CB_STEPPED,\n\r&nbsp;&nbsp;&nbsp; CB_ATTACH,\n\r&nbsp;&nbsp;&nbsp; CB_DETACH,\n\r&nbsp;&nbsp;&nbsp; CB_DEBUGEVENT,\n\r&nbsp;&nbsp;&nbsp; CB_MENUENTRY,\n\r&nbsp;&nbsp;&nbsp; CB_WINEVENT,\n\r  &nbsp;&nbsp;&nbsp; CB_WINEVENTGLOBAL&nbsp;                     \n\r\n\rReturn Values\n\rThis function returns true when the callback was removed without problems.                     ","_plugin_unregistercallback","scr\\plugin_unregistercallback.htm","\n\r\n\r_plugin_unregistercommand\n\rThis function removes a command set by a plugin. It is only possible to remove commands that you previously registered uing _plugin_registercommand.\n\r\n\rbool _plugin_unregistercommand( \n\rint pluginHandle, //plugin handle\n\rconst char* command //command name\n\r); \n\r\n\rParameters \n\r\n\rpluginHandle: Handle of the calling plugin. \n\r\n\rcommand: Command name. \n\r\n\rReturn Values\n\rThis function returns true when the callback was removed without problems. \n\r\n\r&nbsp;                     ","_plugin_unregistercommand","scr\\plugin_unregistercommand.htm","\n\r\n\rpluginit\n\rThis structure is used by the only needed export in the plugin interface:\n\r\n\rstruct PLUG_INITSTRUCT\n\r{\n\r&nbsp;&nbsp;&nbsp; //data provided by the debugger to the plugin.\n\r&nbsp;&nbsp;&nbsp; [IN] int pluginHandle; //handle of the plugin\n\r              \n\r&nbsp;&nbsp;&nbsp;&nbsp;//data provided by the plugin to the debugger (required).\n\r&nbsp;&nbsp;&nbsp; [OUT] int sdkVersion; //plugin SDK version,&nbsp;use the PLUG_SDKVERSION define for this\n\r&nbsp;&nbsp;&nbsp; [OUT] int pluginVersion; //plugin version, useful for crash reports\n\r&nbsp;&nbsp;&nbsp; [OUT] char pluginName[256]; //plugin name, also useful for crash reports\n\r };","PLUG_INITSTRUCT","scr\\PLUGINIT_STRUCT.htm","\n\r\n\rPlugins\n\rThis section describes various plugin functions for x64_dbg.\n\r\n\rYou can install plugins by copying the *.dp32 (x32 plugins) or *.dp64 (x64 plugins) to the \'plugins\' directory.","Plugins","scr\\Plugins.htm","\n\r\n\rPlugins\n\rThis section contains debugger-embedded plugin commands.","Plugins","scr\\Plugins_section.htm","\n\r\n\rrefadd\n\rAdd an entry to the reference view. You need to call \'refinit\' before using refadd.\n\r\n\rarguments\n\r&nbsp; arg1: Address to put in the reference view.\n\r\n\r&nbsp; arg2: Text to put after the address.\n\r\n\rresult\n\r      This command does not set any result variables.","refadd","scr\\refadd.htm","\n\r\n\rreffind[,findref,ref]\n\rFind references to a certain value.\n\r\n\rarguments \n\r&nbsp; arg1: The value to look for.\n\r\n\r[arg2]: Address&nbsp;of/inside a memory page to look in. When not specified CIP will be used.&nbsp;\n\r\n\r      [arg3]: The size of the data to search in.\n\r\n\r  result \n\rThe $result variable is set to the number of references found. ","reffind/findref/ref","scr\\reffind_findref_ref.htm","\n\r\n\rrefinit\n\rInitialize reference view for command usage.\n\r\n\rarguments\n\r This command has no arguments.\n\r\n\rresult\n\r     This command does not set any result variables.","refinit","scr\\refinit.htm","\n\r\n\rrefstr[,strref]\n\rFind referenced text strings.\n\r\n\rarguments \n\r[arg1]: Address of/inside a memory page to&nbsp;find referenced text&nbsp;strings in. When not specified CIP will be used.\n\r\n\r        [arg2]: The size of the data to search in.\n\r\n\rresult \n\rThe $result variable is set to the number of string references found.","refstr/strref","scr\\refstr_strref.htm","\n\r\n\rresumethread[,threadresume]\n\rResume a thread in the debuggee.\n\r\n\rarguments&nbsp;\n\r[arg1]:&nbsp;ThreadId of the thread to&nbsp;resume&nbsp;(see the Threads tab). When not specified, the main thread is used.&nbsp;\n\r\n\rresult \n\rThis command does not set any result variables.","resumethread/threadresume","scr\\resumethread_threadresume.htm","\n\r\n\rret\n\rWhen called without an entry on the stack, this command will end the script and set the script IP to the first line. When \'call\' was executed before, ret will return from that call.\n\r\n\rarguments \n\rThis command has no arguments. \n\r\n\rresult \n\rThis command does not set any result variables. ","ret","scr\\ret.htm","\n\r\n\rrol\n\rBinary ROL a value.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\r&nbsp; arg2: Source.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","rol","scr\\rol.htm","\n\r\n\rror\n\rBinary ROR a value.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\r&nbsp; arg2: Source.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","ror","scr\\ror.htm","\n\r\n\rStepOut[,rtr]\n\rReturn from function by calling StepOver until the current instruction is a RET.\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\rresult\n\r            This command does not set any result variables.","StepOut/rtr","scr\\rtr.htm","\n\r\n\rrun[,go,r,g]\n\rFree the lock and allow the program to run.\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\rresult\n\rThis command does not set any result variables.","run/go/r/g","scr\\run_go_r_g.htm","\n\r\n\rsavedb[,dbsave]\n\rSave the program database from memory to disk.\n\r\n\rarguments \n\rThis command has no arguments.\n\r\n\r result\n\rThis command does not set any result variables.","savedb/dbsave","scr\\savedb_dbsave.htm","\n\r\n\rScript Commands\n\rThis section contains various commands that are only used or available in a scripting context. Commands that also exist in a non-scripting context have priority.","Script Commands","scr\\Script_Commands.htm","\n\r\n\rScripting\n\rThis sections provides an overview of automating tasks with x64_dbg using scripts. See Commands for a description of all possible script commands. See Introduction for an introduction to expressions.","Scripting","scr\\Scripting.htm","\n\r\n\rscriptload\n\rLoad a script file.\n\r\n\rarguments\n\r&nbsp;arg1: Script file to load.\n\r\n\rresult\n\rThis command does not set any result variables.","scriptload","scr\\scriptload.htm","\n\r\n\rsdump\n\rDump the&nbsp;at a certain position.\n\r\n\rarguments \n\r[arg1]: The address to dump at (must be inside the thread stack range).\n\r\n\r  result \n\rThis command does not set any result variables. \n\r\n\r&nbsp;","sdump","scr\\sdump.htm","\n\r\n\rSetBPX[,bp,bpx]\n\rSet an INT3 (SHORT/LONG)&nbsp;or UD2 breakpoint and optionally assign a name to it.\n\r\n\rarguments\n\r&nbsp; arg1: Address to put a breakpoint on. This can be an API name&nbsp;[not            implemented].\n\r\n\r            [arg2]: Name of the breakpoint, use quotation marks to include spaces. This name can be used            by the EnableBPX, DisableBPX and DeleteBPX functions as alias, but is mainly intended to provide a single line of information about the currently-hit breakpoint. When arg2 equals to a            valid type (arg3) the type is used and arg2 is            ignored.\n\r\n\r            [arg3]: Breakpoint type. Can be one of the following options            in random order: \"ss\" (single shot breakpoint), \"long\" (CD03), \"ud2\" (0F0B) and \"short\" (CC). You can combine the \"ss\" option with one of the type options in one string. Example: \"SetBPX 00401000,\"entrypoint\",ssud2\" will set a single shot&nbsp;UD2&nbsp;breakpoint at 00401000 with the name \"entrypoint\".            When specifying no type or just the type \"ss\" the default type will be used. Per default this equals to the \"short\" type. You can change the default type using the \"SetBPXOptions\"            command.\n\r\n\rresult\n\r                                         This command&nbsp;does&nbsp;not any&nbsp;result            variables.","SetBPX/bp/bpx","scr\\SetBPX_bp_bpx.htm","\n\r\n\rSetBPXOptions[,bptype]\n\rSet the default type for the \"SetBPX\" command.\n\r\n\rarguments\n\r&nbsp; arg1: Default type. This can be \"short\" (CC), \"long\" (CD03) or \"ud2\" (0F0B). Type default type affects both NORMAL and SINGLESHOT breakpoints.\n\r\n\rresult\n\rThis command does not set any result variables.","SetBPXOptions/bptype","scr\\SetBPXOptions_bptype.htm","\n\r\n\rSetHardwareBreakpoint[,bph,bphws]\n\rSet a hardware breakpoint (using debug registers).\n\r\n\rarguments \n\r       &nbsp; arg1: Address&nbsp;of the hardware breakpoint.&nbsp; \n\r\n\r[arg2]:&nbsp;Hardware breakpoint type. Can be either \'r\' (readwrite), \'w\' (write) or \'x\' (execute). When not specified, \'x\' is assumed.&nbsp; \n\r\n\r                    [arg3]:&nbsp;Hardware breakpoint size.&nbsp;Can be either \'1\', \'2\', \'4\' or \'8\' (x64 only). Per default, \'1\' is assumed. The address you\'re putting the hardware breakpoint on must be aligned to the specified size. \n\r\n\rresult \n\rThis command does not set any result variables. ","SetHardwareBreakpoint/bph/bphws","scr\\SetHardwareBreakpoint_bph_bphws.htm","\n\r\n\rSetMemoryBPX[,membp,bpm]\n\rSet a memory breakpoint (GUARD_PAGE) on the whole memory region the provided address is in.\n\r\n\rarguments\n\r     &nbsp; arg1:&nbsp;Address&nbsp;of or inside a memory region that will be watched.\n\r\n\r       [arg2]: 1/0 restore the memory breakpoint once it\'s hit? When this value is not equal to one, it\'s assumed to be arg3. This means \"bpm eax,r\" would be the same command as: \"bpm eax,0,r\".\n\r\n\r[arg3]: Breakpoint type, it can be \'r\' (execute+read),&nbsp;\'w\' (write) or \'x\' (execute). Per default, it\'s a combination of execute, read and write.\n\r\n\rresult\n\rThis command does not set any result variables.              \n\r\n\r&nbsp;","SetMemoryBPX/membp/bpm","scr\\SetMemoryBPX_membp_bpm.htm","\n\r\n\rsetthreadpriority[,setprioritythread,threadsetpriority]\n\rSet thread priority in the debuggee.\n\r\n\rarguments&nbsp;\n\r&nbsp; arg1:&nbsp;ThreadId of the thread to&nbsp;change the priority of&nbsp;(see the Threads tab). \n\r\n\r&nbsp; arg2: Priority value, this can be the integer of a valid thread priority (see MSDN)&nbsp;or&nbsp;one of the following values: \"Normal\", \"AboveNormal\", \"TimeCritical\", \"Idle\", \"BelowNormal\", \"Highest\", \"Lowest\".\n\r\n\rresult \n\rThis command does not set any result variables.     ","setthreadpriority/setprioritythread/threadsetpriority","scr\\setthreadpriority_setprioritythread_threadsetpriority.htm","\n\r\n\rshl\n\rBinary SHL a value.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\r&nbsp; arg2: Source.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","shl","scr\\shl.htm","\n\r\n\rshr\n\rBinary SHR a value.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\r&nbsp; arg2: Source.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","shr","scr\\shr.htm","\n\r\n\rSingleStep[,sstep,sst]\n\rStep a specified number of instructions using the Trap-Flag.\n\r\n\rarguments\n\r    [arg1]: The number of instructions to executre (this can be any valid expression). When not specified, a StepInto is performed.\n\r\n\r\n\rresult\n\rThis command does not set any result variables.","SingleStep/sstep/sst","scr\\SingleStep.htm","\n\r\n\rsleep\n\rSleep for a specified number of milliseconds.\n\r\n\rarguments \n\r[arg1]: Number of milliseconds to sleep, 100 (decimal)&nbsp;milliseconds will be taken when nothing is specified Keep in mind that default input is in HEX.\n\r\n\r  result \n\rThis command does not set any result variables.","sleep","scr\\sleep.htm","\n\r\n\rCredits\n\r     This page is reserved for people/organisations that contributed to x64_dbg.\n\r  Debugger core by&nbsp;TitanEngine Community Edition         Disassembly powered by&nbsp;BeaEngine (Updated)    Assembly powered by&nbsp;XEDParse       Import reconstruction powered by&nbsp;Scylla        JSON powered by&nbsp;Jansson       Database compression powered by&nbsp;lz4        Bug icon by&nbsp;VisualPharm       Interface icons by&nbsp;Fugue        Website by&nbsp;tr4ceflow     \n\r\n\r\n\rSpecial Thanks\n\racidflash, cyberbob, Teddy Rogers, EXETools community, Tuts4You community, TEAM DVT, DMichael, Artic, Nukem, ahmadmansoor  \n\r\n\rDevelopers             \n\r  Mr.   eXoDia   &nbsp;       Sigma    tr4ceflow   &nbsp;  \n\r","Credits","scr\\Special_Thanks.htm","\n\r\n\rStartScylla[,scylla,imprec]\n\rStart the Scylla plugin auto-selecting the currently debugged DLL/EXE.\n\r\n\rarguments \n\rThis command has no arguments.\n\r\n\rresult\n\rThis command does not set any result variables.","StartScylla/scylla/imprec","scr\\StartScylla_scylla_imprec.htm","\n\r\n\rStepInto[,sti]\n\rSingle Step (using Trap-Flag).\n\r\n\rarguments\n\rThis command has no arguments.\n\r\n\r\n\rresult\n\rThis command does not set any result variables.","StepInto/sti","scr\\StepInto.htm","\n\r\n\rStepOver[,step,sto,st]\n\rStep over calls. When the instruction at CIP isn\'t a call,&nbsp;a StepInto is performed.\n\r\n\rarguments\n\rThis command has no arguments.             \n\r\n\rresult\n\rThis command does not set any result variables.","StepOver/step/sto/st","scr\\StepOver.htm","\n\r\n\rStopDebug[,stop,dbgstop]\n\rTerminate the current debuggee and stop debugging it.\n\r\n\r  arguments\n\rThis command has no arguments. \n\r\n\rresult\n\rThis command does not set any result variables.","StopDebug/stop/dbgstop","scr\\StopDebug_stop_dbgstop.htm","\n\r\n\rstrlen[,charcount,ccount]\n\rGet the length of a string. This was the first command ever, left in for historical reasons.\n\r\n\r\n\rarguments\n\r&nbsp; arg1: String you want to get the length of.\n\r\n\r\n\rresult\n\rThis command does not set any result variables.","strlen/charcount/ccount","scr\\strlen_charcount_ccount.htm","\n\r\n\rStructures\n\rThis section describes the various plugin SDK structures.","Structures","scr\\Structures.htm","\n\r\n\rsub\n\rSubtract two values.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\r&nbsp; arg2: Source.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","sub","scr\\sub.htm","\n\r\n\rsuspendthread[,threadsuspend]\n\rSuspend a thread in the debuggee.\n\r\n\rarguments&nbsp;\n\r[arg1]:&nbsp;ThreadId of the thread to&nbsp;suspend (see the Threads tab). When not specified, the main thread is used.&nbsp;\n\r\n\rresult\n\r     This command does not set any result variables.","suspendthread/threadsuspend","scr\\suspendthread_threadsuspend.htm","\n\r\n\rswitchthread[,threadswitch]\n\rSwitch the internal current thread to another thread (resulting in&nbsp;different callstack + different registers displayed).\n\r\n\rarguments&nbsp;\n\r[arg1]:&nbsp;ThreadId of the thread to switch to (see the Threads tab). When not specified, the main thread is used.&nbsp;\n\r\n\rresult \n\r This command does not set any result variables.","switchthread/threadswitch","scr\\switchthread_threadswitch.htm","\n\r\n\rsymdownload[,downloadsym]\n\rAttempt to download a symbol from a Symbol Store.\n\r\n\rarguments\n\r [arg1]: Module name (with or without extension) to attept to download symbols for. When not specified, an attempt will be done to download symbols for all loaded modules.\n\r\n\r [arg2]: Symbol Store URL. When not specified, the&nbsp;default store          will be used.\n\r\n\rresult\n\r        This command does not set any result variables.","symdownload/downloadsym","scr\\symdownload_downloadsym.htm","\n\r\n\rtest\n\rBinary TEST a value.\n\r\n\rarguments \n\r&nbsp; arg1: Value to test.\n\r\n\r&nbsp; arg2: Tester.\n\r\n\rresult\n\rThis command&nbsp;sets the internal variables $_EZ_FLAG and $_BS_FLAG. $_EZ_FLAG is set to 1 when arg1&amp;arg2=  =     0. $_BS_FLAG is always set to 0.","test","scr\\test.htm","\n\r\n\rThe basics\n\rThis page covers the basic principles of plugin development for x64_dbg.\n\r\n\rExports\n\rA plugin has at least one export. This export must be called pluginit. See the PLUG_INITSTRUCT and the plugin headers for more information. The other valid exports are:\n\r\n\rplugstop: called when the plugin is about to be unloaded. Remove all registered commands and callbacks here. Also clean up plugin data.\n\r\n\rplugsetup: Called when the plugin initialization was successful, here you can register menus and other GUI-related things.\n\r\n\rCB*: Instead of calling _plugin_registercallback, you can create a CDECL export which has the name of the callback. For example when you create an export called \"CBMENUENTRY\", this will be registered as your callback for the event CB_MENUENTRY. Notice that you should not          use an underscore in the export name.\n\r\n\rCBALLEVENTS: An export with the name \"CBALLEVENTS\" will get every event registered to it. This is done          prior to registering optional other export names.","The basics","scr\\The_basics.htm","\n\r\n\rUser Database\n\rThis section contains commands that manipulate the user database (comments, labels and bookmarks).","User Database","scr\\User_Database.htm","\n\r\n\rvar[,varnew]\n\rDeclare a new variable.\n\r\n\r\n\rarguments\n\r&nbsp; arg1: Variable name (will be prefixed with \'$\' if not done).         \n\r\n\r         [arg2]: Initial variable value (see console input for details).\n\r\n\rresult\n\rThis command does not set any result variables.","var/varnew","scr\\var_varnew.htm","\n\r\n\rvardel\n\rDelete a user-defined variable.\n\r\n\r\n\rarguments\n\r&nbsp; arg1: Name of the variable to delete ($ will be prepended when not present).\n\r\n\r\n\rresult\n\rThis command does not set any result variables.","vardel","scr\\vardel.htm","\n\r\n\rVariables\n\rThis program supports variables. There are three types of variables:\n\r\n\r\n\rUSER: Variables created by the user using the \"var\" command. These variables have no access restrictions.\n\r\n\r\n\rSYSTEM: Variables created by the system, that can be read and written, but cannot be deleted.\n\r\n\r\n\rREADONLY: Variables created by the system, that can be read, but not written or deleted.\n\r\n\r\n\rReserved Variables\n\rThere are a few reserved variables:\n\r\n\r\n\r$res/$result: General result variable.\n\r$resN/$resultN: Optional other result variables (N=   1-4).\n\r$pid: Project ID of the debugged executable.\n\r$hp/$hProcess: Debugged executable handle.\n\r$lastalloc: Last result of the \'alloc\' command.","Variables","scr\\Variables.htm","\n\r\n\rVariables\n\rThis section contains commands that can manipulate variables.","Variables","scr\\Variables_section.htm","\n\r\n\rvarlist\n\rGet a list of all variables and their values.\n\r\n\r\n\rarguments\n\r[arg1]: Filter (USER, SYSTEM, READONLY).\n\r\n\r\n\rresult\n\rThis command does not set any result variables.","varlist","scr\\varlist.htm","\n\r\n\rxor\n\rBinary XOR&nbsp;two values.\n\r\n\rarguments \n\r&nbsp; arg1: Destination.\n\r\n\r &nbsp; arg2: Source.\n\r\n\rresult\n\rThis command does not set any result&nbsp;variables.","xor","scr\\xor.htm");